#!/usr/bin/env node
'use strict';

var fs = require('fs');
var path = require('path');
var program = require('commander');
var constants = require('./constants');
var colors = require("colors");
var emoji = require('node-emoji');
var Table = require('cli-table2');
var depcheck = require('depcheck');
var shelljs = require('shelljs');
var rootPath = path.resolve();

var packageJSON = void 0;
var table = new Table({ head: ['Package', 'Base Size (in kb)', 'Direct Children'] });
var universalVersioning = [];
var numbering = 0;

try {
  packageJSON = require(rootPath + '/package.json');
} catch (e) {
  console.log(colors.red('Error finding package JSON in your project folder, make sure it is in the root and it is valid'));
  process.exit();
}

program.usage('clean-package-json [options]').option('-lock, --lock [num]', 'Lock versions for production').option('-yarn, --yarn [num]', 'Use Yarn for installation').on('--help', function () {
  console.log(colors.green(`Run in your project root folder containing package.json`));
}).parse(process.argv);

/**
 * prettity the package JSON with 2 space format
 */
var prettify = function prettify() {
  packageJSON = JSON.stringify(packageJSON, null, 2);
  console.log(colors.green(emoji.get('thumbsup') + '  Removed duplicate dependencies'));
  console.log(colors.green(emoji.get('thumbsup') + '  Prettify package.json'));
};

/**
 * When the lock argument is passed, removes wildcards from version numbers
 */
var lockVersions = function lockVersions() {
  for (var pkg in packageJSON.dependencies) {
    if (packageJSON.dependencies[pkg].match(/\*/)) {
      universalVersioning.push(pkg);
      numbering++;
    };
    packageJSON.dependencies[pkg] = packageJSON.dependencies[pkg].replace('^', '');
  }
  console.log(colors.green(emoji.get('thumbsup') + '  Locked versions of packages'));
};

/**
 * Sorts the package JSON alphabetically
 */
var sortAlphabetically = function sortAlphabetically() {
  packageJSON.dependencies = Object.keys(packageJSON.dependencies).sort(function (a, b) {
    return a < b ? -1 : 1;
  }).reduce(function (dependencies, value) {
    dependencies[value] = packageJSON.dependencies[value];
    return dependencies;
  }, {});
  console.log(colors.green(emoji.get('thumbsup') + '  Sorted dependencies alphabetically'));
};

/**
 * Writes to the FS
 */
var updateFile = function updateFile() {
  fs.writeFileSync(rootPath + '/package.json', packageJSON);
  console.log(colors.green(emoji.get('thumbsup') + '  Updated Package JSON file'));
};

/**
 * Recursively returns the size of the folder
 */
var getDirSize = function getDirSize(dir) {
  var total = 0;
  try {
    var stat = fs.lstatSync(dir);
    if (stat.isFile()) {
      total += stat.size;
    } else if (stat.isDirectory()) {
      var files = fs.readdirSync(dir);
      files.forEach(function (file) {
        if (file) total += getDirSize(path.join(dir, file));
      });
    }
  } catch (e) {
    console.log("Error while calculating dir size!");
  }
  return total;
};

/**
 * Prints to the console
 */
var printTips = function printTips() {
  if (numbering) {
    console.log();
    console.log(colors.green('Tips to improve install times:'));
    console.log('******************************************');
    console.log();
    if (universalVersioning.length) {
      console.log(colors.green('The following packages have not recommended \'*\' wildcard in their version'));
      console.log();
      universalVersioning.forEach(function (pkg, idx) {
        console.log(idx + 1 + '. ' + pkg);
      });
    }
    console.log();
    console.log(colors.green('The following packages in dependencies can be moved to devDependencies:'));
    console.log();
    if (table.length) {
      console.log(table.toString());
    }
  } else {
    console.log();
    console.log();
    console.log(emoji.get('100') + '  Your package JSON looks good');
  }
};

/**
 * Get a list of packages that could be moved to most
 * commonly downloaded devDependencies
 */
var checkDependencies = function checkDependencies() {
  try {
    for (var pkg in packageJSON.dependencies) {
      constants.devDependencies.forEach(function (devDep, i) {
        if (pkg.match(devDep)) {
          numbering++;
          var packageRoot = rootPath + '/node_modules/' + pkg;
          var childRen = require(packageRoot + '/package.json').dependencies;
          var size = parseInt(getDirSize(packageRoot) / 1024, 10);
          table.push([pkg, size, Object.keys(childRen).length]);
        }
      });
    }
  } catch (e) {
    console.log('Errored while fetching devDependencies');
  }
};

var cleanUp = function cleanUp(options) {
  console.log();
  console.log('Installing dependencies first..');
  shelljs.exec(options.yarn ? 'yarn install' : 'npm install');
  console.log();
  console.log();
  options.lock && lockVersions();
  sortAlphabetically();
  checkDependencies();
  prettify();
  updateFile();
  printTips();
  console.log();
};

cleanUp({
  lock: program.lock,
  yarn: program.yarn
});